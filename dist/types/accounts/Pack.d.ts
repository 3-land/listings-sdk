import { PublicKey, Connection } from "@solana/web3.js";
import BN from "bn.js";
import * as types from "../types";
export interface PackFields {
    class: types.AccountClassKind;
    globalState: types.GlobalStateKind;
    holder: PublicKey;
    creator: PublicKey;
    dates: types.IndexDatesFields;
    category: types.CategoryFields;
    superCategory: types.SuperCategoryFields;
    eventCategory: number;
    trackType: types.TrackRegistryKind;
    mainCurrencyHash: BN;
    track: types.ItemTrackFields;
    popularity: types.PopularityFields;
    filtering: types.FilterFields;
    page: BN;
    manager: PublicKey;
    isServerless: number;
    availableOption: number;
    hasWrappedTokens: number;
    burntPieces: number;
    flag: Array<number>;
    item: types.ItemFields;
    count: BN;
    live: BN;
    available: BN;
    printed: BN;
    saleConfig: types.SaleConfigFields;
    opened: BN;
    owed: BN;
    identifier: BN;
    hash: BN;
    hashTraits: BN;
    packConfig: types.PackConfigFields;
    volume: Array<types.FakeVolumeTrackFields>;
    delegate: Array<PublicKey>;
    extra: Array<number>;
}
export interface PackJSON {
    class: types.AccountClassJSON;
    globalState: types.GlobalStateJSON;
    holder: string;
    creator: string;
    dates: types.IndexDatesJSON;
    category: types.CategoryJSON;
    superCategory: types.SuperCategoryJSON;
    eventCategory: number;
    trackType: types.TrackRegistryJSON;
    mainCurrencyHash: string;
    track: types.ItemTrackJSON;
    popularity: types.PopularityJSON;
    filtering: types.FilterJSON;
    page: string;
    manager: string;
    isServerless: number;
    availableOption: number;
    hasWrappedTokens: number;
    burntPieces: number;
    flag: Array<number>;
    item: types.ItemJSON;
    count: string;
    live: string;
    available: string;
    printed: string;
    saleConfig: types.SaleConfigJSON;
    opened: string;
    owed: string;
    identifier: string;
    hash: string;
    hashTraits: string;
    packConfig: types.PackConfigJSON;
    volume: Array<types.FakeVolumeTrackJSON>;
    delegate: Array<string>;
    extra: Array<number>;
}
export declare class Pack {
    readonly class: types.AccountClassKind;
    readonly globalState: types.GlobalStateKind;
    readonly holder: PublicKey;
    readonly creator: PublicKey;
    readonly dates: types.IndexDates;
    readonly category: types.Category;
    readonly superCategory: types.SuperCategory;
    readonly eventCategory: number;
    readonly trackType: types.TrackRegistryKind;
    readonly mainCurrencyHash: BN;
    readonly track: types.ItemTrack;
    readonly popularity: types.Popularity;
    readonly filtering: types.Filter;
    readonly page: BN;
    readonly manager: PublicKey;
    readonly isServerless: number;
    readonly availableOption: number;
    readonly hasWrappedTokens: number;
    readonly burntPieces: number;
    readonly flag: Array<number>;
    readonly item: types.Item;
    readonly count: BN;
    readonly live: BN;
    readonly available: BN;
    readonly printed: BN;
    readonly saleConfig: types.SaleConfig;
    readonly opened: BN;
    readonly owed: BN;
    readonly identifier: BN;
    readonly hash: BN;
    readonly hashTraits: BN;
    readonly packConfig: types.PackConfig;
    readonly volume: Array<types.FakeVolumeTrack>;
    readonly delegate: Array<PublicKey>;
    readonly extra: Array<number>;
    static readonly discriminator: Buffer;
    static readonly layout: any;
    constructor(fields: PackFields);
    static fetch(c: Connection, address: PublicKey, programId?: PublicKey): Promise<Pack | null>;
    static fetchMultiple(c: Connection, addresses: PublicKey[], programId?: PublicKey): Promise<Array<Pack | null>>;
    static decode(data: Buffer): Pack;
    toJSON(): PackJSON;
    static fromJSON(obj: PackJSON): Pack;
}
//# sourceMappingURL=Pack.d.ts.map